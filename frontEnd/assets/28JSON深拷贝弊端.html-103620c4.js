import{_ as t,M as s,p as r,q as l,R as n,t as e,N as i}from"./framework-96b046e1.js";const c={},_=n("h1",{id:"_28-json深拷贝弊端",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_28-json深拷贝弊端","aria-hidden":"true"},"#"),e(" 28 JSON深拷贝弊端")],-1),a=n("p",null,"Function、Class、Error对象 变 null，",-1),d=n("p",null,"NaN、undefined 变 null",-1),u=n("p",null,"JSON.stringify()只能序列化对象的可枚举的自有属性。如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor。",-1),f={href:"https://blog.csdn.net/Ares0412/article/details/127386317",target:"_blank",rel:"noopener noreferrer"},p=n("blockquote",null,[n("p",null,"浅拷贝 ： 只是将数据中所有的数据引用下来，依旧指向同一个存放地址，拷贝之后的数据修改之后，也会影响到原数据的中的对象数据。例如:Object.assign(),…扩展运算符")],-1),N=n("blockquote",null,[n("p",null,"深拷贝： 将数据中所有的数据拷贝下来，对拷贝之后的数据进行修改不会影响到原数据。")],-1),h=n("blockquote",null,[n("p",null,"JSON.parse(JSON.stringify(obj))深拷贝的问题 1、如果obj里面存在时间对象,JSON.parse(JSON.stringify(obj))之后，时间对象变成了字符串。 2、如果obj里有RegExp、Error对象，则序列化的结果将只得到空对象。 3、如果obj里有函数，undefined，则序列化的结果会把函数， undefined丢失。 4、如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null。 5、JSON.stringify()只能序列化对象的可枚举的自有属性。如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor。 6、如果对象中存在循环引用的情况也无法正确实现深拷贝。")],-1);function b(O,j){const o=s("ExternalLinkIcon");return r(),l("div",null,[_,a,d,u,n("p",null,[n("a",f,[e("原文"),i(o)])]),p,N,h])}const S=t(c,[["render",b],["__file","28JSON深拷贝弊端.html.vue"]]);export{S as default};
