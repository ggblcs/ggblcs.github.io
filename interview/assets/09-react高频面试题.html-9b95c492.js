import{_ as a,p as n,q as s,a1 as e}from"./framework-96b046e1.js";const t={},i=e(`<h1 id="_09-react高频面试题" tabindex="-1"><a class="header-anchor" href="#_09-react高频面试题" aria-hidden="true">#</a> 09 -react高频面试题</h1><h3 id="react高频面试题" tabindex="-1"><a class="header-anchor" href="#react高频面试题" aria-hidden="true">#</a> react高频面试题</h3><h4 id="_1、什么是虚拟dom" tabindex="-1"><a class="header-anchor" href="#_1、什么是虚拟dom" aria-hidden="true">#</a> 1、什么是虚拟DOM？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	虚拟 <span class="token constant">DOM</span> <span class="token punctuation">(</span><span class="token constant">VDOM</span><span class="token punctuation">)</span>是真实 <span class="token constant">DOM</span> 在内存中的表示。<span class="token constant">UI</span> 的表示形式保存在内存中，并与实际的 <span class="token constant">DOM</span> 同步。这是一个发生在渲染函数被调用和元素在屏幕上显示之间的步骤，整个过程被称为调和。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_2、虚拟dom实现的原理" tabindex="-1"><a class="header-anchor" href="#_2、虚拟dom实现的原理" aria-hidden="true">#</a> 2、虚拟DOM实现的原理？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token number">1</span><span class="token punctuation">)</span>虚拟<span class="token constant">DOM</span>本质上是JavaScript对象<span class="token punctuation">,</span>是对真实<span class="token constant">DOM</span>的抽象
<span class="token number">2</span><span class="token punctuation">)</span>状态变更时，记录新树和旧树的差异
<span class="token number">3</span><span class="token punctuation">)</span>最后把差异更新到真正的dom中
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_3、类组件和函数组件之间的区别是啥" tabindex="-1"><a class="header-anchor" href="#_3、类组件和函数组件之间的区别是啥" aria-hidden="true">#</a> 3、类组件和函数组件之间的区别是啥？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	类组件可以使用其他特性，如状态 state 和生命周期钩子。
    当组件只是接收 props 渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。
    函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。如果都能满足需求的情况下，为了提高性能，尽量使用函数组件。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_4、react-中-refs-干嘛用的" tabindex="-1"><a class="header-anchor" href="#_4、react-中-refs-干嘛用的" aria-hidden="true">#</a> 4、React 中 refs 干嘛用的？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	Refs 提供了一种访问在render方法中创建的 <span class="token constant">DOM</span> 节点或者 React 元素的方法。
	可以在组件添加一个 ref 属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层 <span class="token constant">DOM</span> 元素或组件的挂载实例。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_5、在-react-中如何处理事件" tabindex="-1"><a class="header-anchor" href="#_5、在-react-中如何处理事件" aria-hidden="true">#</a> 5、在 React 中如何处理事件？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	<span class="token function">为了解决跨浏览器的兼容性问题，SyntheticEvent</span><span class="token punctuation">(</span>事件e<span class="token punctuation">)</span> 实例将被传递给你的事件处理函数，SyntheticEvent是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括 <span class="token function">stopPropagation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 和 <span class="token function">preventDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span>。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_6、state-和-props-区别是啥" tabindex="-1"><a class="header-anchor" href="#_6、state-和-props-区别是啥" aria-hidden="true">#</a> 6、state 和 props 区别是啥？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	props和state是普通的 <span class="token constant">JS</span> 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即
	<span class="token number">1</span><span class="token punctuation">)</span>state 是组件自己管理数据，控制自己的状态，可变；
	<span class="token number">2</span><span class="token punctuation">)</span>props 是外部传入的数据参数，不可变；
	<span class="token number">3</span><span class="token punctuation">)</span>没有state的叫做无状态组件，有state的叫做有状态组件；
	<span class="token number">4</span><span class="token punctuation">)</span>多用 props，少用 state，也就是多写无状态组件。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_7、如何创建-refs" tabindex="-1"><a class="header-anchor" href="#_7、如何创建-refs" aria-hidden="true">#</a> 7、如何创建 refs？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	Refs 是使用 React<span class="token punctuation">.</span><span class="token function">createRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 创建的，并通过 ref 属性附加到 React 元素。在构造组件时，通常将 Refs 分配给实例属性，以便可以在整个组件中引用它们。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_8、什么是高阶组件" tabindex="-1"><a class="header-anchor" href="#_8、什么是高阶组件" aria-hidden="true">#</a> 8、什么是高阶组件？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	<span class="token function">高阶组件</span><span class="token punctuation">(</span><span class="token constant">HOC</span><span class="token punctuation">)</span>是接受一个组件并返回一个新组件的函数。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为纯组件，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_9、在构造函数调用-super-并将-props-作为参数传入的作用是啥" tabindex="-1"><a class="header-anchor" href="#_9、在构造函数调用-super-并将-props-作为参数传入的作用是啥" aria-hidden="true">#</a> 9、在构造函数调用 <code>super</code> 并将 <code>props</code> 作为参数传入的作用是啥？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	在调用 <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 方法之前，子类构造函数无法使用<span class="token keyword">this</span>引用，<span class="token constant">ES6</span> 子类也是如此。将 props 参数传递给 <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 调用的主要原因是在子构造函数中能够通过<span class="token keyword">this</span><span class="token punctuation">.</span>props来获取传入的 props。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_10、什么是控制组件" tabindex="-1"><a class="header-anchor" href="#_10、什么是控制组件" aria-hidden="true">#</a> 10、什么是控制组件？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	在 <span class="token constant">HTML</span> 中，表单元素如 <span class="token operator">&lt;</span>input<span class="token operator">&gt;</span>、<span class="token operator">&lt;</span>textarea<span class="token operator">&gt;</span>和<span class="token operator">&lt;</span>select<span class="token operator">&gt;</span>通常维护自己的状态，并根据用户输入进行更新。当用户提交表单时，来自上述元素的值将随表单一起发送。
	而 React <span class="token function">的工作方式则不同。包含表单的组件将跟踪其状态中的输入值，并在每次回调函数</span><span class="token punctuation">(</span>例如onChange<span class="token punctuation">)</span>触发时重新渲染组件，因为状态被更新。以这种方式由 React 控制其值的输入表单元素称为受控组件。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_11、讲讲什么是-jsx" tabindex="-1"><a class="header-anchor" href="#_11、讲讲什么是-jsx" aria-hidden="true">#</a> 11、讲讲什么是 JSX ？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	jsx是JavaScript的一种语法扩展，它跟模板语言很接近，但是它充分具备JavaScript的能力
	当 Facebook 第一次发布 React 时，他们还引入了一种新的 <span class="token constant">JS</span> 方言 <span class="token constant">JSX</span>，将原始 <span class="token constant">HTML</span> 模板嵌入到 <span class="token constant">JS</span> 代码中。<span class="token constant">JSX</span> 代码本身不能被浏览器读取，必须使用Babel和webpack等工具将其转换为传统的<span class="token constant">JS</span>。
    <span class="token constant">JSX</span>中的标签可以是单标签，也可以是双标签，但必须保证标签是闭合的。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_12、为什么不直接更新-state-呢" tabindex="-1"><a class="header-anchor" href="#_12、为什么不直接更新-state-呢" aria-hidden="true">#</a> 12、为什么不直接更新 <code>state</code> 呢 ?</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	如果试图直接更新 state ，则不会重新渲染组件。
    <span class="token function">需要使用setState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>方法来更新 state。它调度对组件state对象的更新。当state改变时，组件通过重新渲染来响应。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_13、react-组件生命周期有哪些不同阶段" tabindex="-1"><a class="header-anchor" href="#_13、react-组件生命周期有哪些不同阶段" aria-hidden="true">#</a> 13、React 组件生命周期有哪些不同阶段？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>在组件生命周期中有四个不同的阶段：
	<span class="token number">1</span><span class="token punctuation">)</span>Initialization：在这个阶段，组件准备设置初始化状态和默认属性。
	<span class="token number">2</span><span class="token punctuation">)</span>Mounting：react 组件已经准备好挂载到浏览器 <span class="token constant">DOM</span> 中。这个阶段包括componentWillMount和componentDidMount生命周期方法。
	<span class="token number">3</span><span class="token punctuation">)</span>Updating：在这个阶段，组件以两种方式更新，发送新的 props 和 state 状态。此阶段包括shouldComponentUpdate、componentWillUpdate和componentDidUpdate生命周期方法。
	<span class="token number">4</span><span class="token punctuation">)</span>Unmounting：在这个阶段，组件已经不再被需要了，它从浏览器 <span class="token constant">DOM</span> 中卸载下来。这个阶段包含 componentWillUnmount 生命周期方法。
除以上四个常用生命周期外，还有一个错误处理的阶段：
	<span class="token number">5</span><span class="token punctuation">)</span>Error Handling：在这个阶段，不论在渲染的过程中，还是在生命周期方法中或是在任何子组件的构造函数中发生错误，该组件都会被调用。这个阶段包含了 componentDidCatch 生命周期方法。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_14、react-的生命周期方法有哪些" tabindex="-1"><a class="header-anchor" href="#_14、react-的生命周期方法有哪些" aria-hidden="true">#</a> 14、React 的生命周期方法有哪些？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	<span class="token number">1</span><span class="token punctuation">)</span>componentWillMount<span class="token operator">:</span>在渲染之前执行，用于根组件中的 App 级配置。
	<span class="token number">2</span><span class="token punctuation">)</span>componentDidMount：在第一次渲染之后执行，可以在这里做<span class="token constant">AJAX</span>请求，<span class="token constant">DOM</span> 的操作或状态更新以及设置事件监听器。
	<span class="token number">3</span><span class="token punctuation">)</span><span class="token function">componentWillReceiveProps：在初始化render的时候不会执行，它会在组件接受到新的状态</span><span class="token punctuation">(</span>Props<span class="token punctuation">)</span>时被触发，一般用于父组件状态更新时子组件的重新渲染
	<span class="token number">4</span><span class="token punctuation">)</span>shouldComponentUpdate：确定是否更新组件。默认情况下，它返回<span class="token boolean">true</span>。如果确定在 state 或 props 更新后组件不需要在重新渲染，则可以返回<span class="token boolean">false</span>，这是一个提高性能的方法。
	<span class="token number">5</span><span class="token punctuation">)</span>componentWillUpdate：在shouldComponentUpdate返回 <span class="token boolean">true</span> 确定要更新组件之前件之前执行。
	<span class="token number">6</span><span class="token punctuation">)</span>componentDidUpdate：它主要用于更新<span class="token constant">DOM</span>以响应props或state更改。
	<span class="token number">7</span><span class="token punctuation">)</span>componentWillUnmount：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_15、使用-react-hooks-好处是啥" tabindex="-1"><a class="header-anchor" href="#_15、使用-react-hooks-好处是啥" aria-hidden="true">#</a> 15、使用 React Hooks 好处是啥？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	首先，Hooks 通常支持提取和重用跨多个组件通用的有状态逻辑，而无需承担高阶组件或渲染 props 的负担。Hooks 可以轻松地操作函数组件的状态，而不需要将它们转换为类组件。
	Hooks 在类中不起作用，通过使用它们，咱们可以完全避免使用生命周期方法，例如 componentDidMount、componentDidUpdate、componentWillUnmount。相反，使用像useEffect这样的内置钩子。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_16、什么是-react-hooks" tabindex="-1"><a class="header-anchor" href="#_16、什么是-react-hooks" aria-hidden="true">#</a> 16、什么是 React Hooks？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	Hooks是 React <span class="token number">16.8</span> 中的新添加内容。它们允许在不编写类的情况下使用state和其他 React 特性。使用 Hooks，可以从组件中提取有状态逻辑，这样就可以独立地测试和重用它。Hooks 允许咱们在不改变组件层次结构的情况下重用有状态逻辑，这样在许多组件之间或与社区共享 Hooks 变得很容易。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_17、react-中的-usestate-是什么" tabindex="-1"><a class="header-anchor" href="#_17、react-中的-usestate-是什么" aria-hidden="true">#</a> 17、React 中的 <code>useState()</code> 是什么？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	useState 是一个内置的 React <span class="token function">Hook。useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> 返回一个元组，其中第一个参数count是计数器的当前状态，setCounter 提供更新计数器状态的方法。
	可以在任何地方使用setCounter方法更新计数状态<span class="token operator">-</span>在这种情况下，咱们在setCount函数内部使用它可以做更多的事情，使用 Hooks，能够使咱们的代码保持更多功能，还可以避免过多使用基于类的组件。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_18、react-中的strictmode-严格模式-是什么" tabindex="-1"><a class="header-anchor" href="#_18、react-中的strictmode-严格模式-是什么" aria-hidden="true">#</a> 18、React 中的StrictMode(严格模式)是什么？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	React 的StrictMode是一种辅助组件，可以帮助咱们编写更好的 react 组件，可以使用<span class="token operator">&lt;</span>StrictMode <span class="token operator">/</span><span class="token operator">&gt;</span>包装一组组件，并且可以帮咱们以下检查：
	<span class="token number">1</span><span class="token punctuation">)</span>验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告。
	<span class="token number">2</span><span class="token punctuation">)</span>验证是否使用的已经废弃的方法，如果有，会在控制台给出警告。
	<span class="token number">3</span><span class="token punctuation">)</span>通过识别潜在的风险预防一些副作用。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_19、为什么类方法需要绑定到类实例" tabindex="-1"><a class="header-anchor" href="#_19、为什么类方法需要绑定到类实例" aria-hidden="true">#</a> 19、为什么类方法需要绑定到类实例？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	在 <span class="token constant">JS</span> 中，<span class="token keyword">this</span> 值会根据当前上下文变化。在 React 类组件方法中，开发人员通常希望 <span class="token keyword">this</span> 引用组件的当前实例，因此有必要将这些方法绑定到实例。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="_20、受控组件和非受控组件区别是啥" tabindex="-1"><a class="header-anchor" href="#_20、受控组件和非受控组件区别是啥" aria-hidden="true">#</a> 20、受控组件和非受控组件区别是啥？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	受控组件是 React 控制中的组件，并且是表单数据真实的唯一来源。
	非受控组件是由 <span class="token constant">DOM</span> 处理表单数据的地方，而不是在 React 组件中。
	尽管非受控组件通常更易于实现，因为只需使用refs即可从 <span class="token constant">DOM</span> 中获取值，但通常建议优先选择受控制的组件，而不是非受控制的组件。
这样做的主要原因是受控组件支持即时字段验证，允许有条件地禁用<span class="token operator">/</span>启用按钮，强制输入格式。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_21、如何避免组件的重新渲染" tabindex="-1"><a class="header-anchor" href="#_21、如何避免组件的重新渲染" aria-hidden="true">#</a> 21、如何避免组件的重新渲染？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	React 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用：
	<span class="token number">1</span><span class="token punctuation">)</span>React<span class="token punctuation">.</span><span class="token function">memo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>这可以防止不必要地重新渲染函数组件
	<span class="token number">2</span><span class="token punctuation">)</span>PureComponent<span class="token operator">:</span>这可以防止不必要地重新渲染类组件
	这两种方法都依赖于对传递给组件的props的浅比较，如果 props 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。
	通过使用 React Profiler，可以在使用这些方法前后对性能进行测量，从而确保通过进行给定的更改来实际改进性能。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_22、如何避免在react重新绑定实例-解决this指向" tabindex="-1"><a class="header-anchor" href="#_22、如何避免在react重新绑定实例-解决this指向" aria-hidden="true">#</a> 22、如何避免在React重新绑定实例(解决this指向)？</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>有几种常用方法可以避免在 React 中绑定方法：
	<span class="token number">1</span><span class="token punctuation">)</span>将事件处理程序定义为内联箭头函数
	<span class="token number">2</span><span class="token punctuation">)</span>使用箭头函数来定义方法
	<span class="token number">3</span><span class="token punctuation">)</span>使用带有 Hooks 的函数组件
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_23、react组件通信如何实现" tabindex="-1"><a class="header-anchor" href="#_23、react组件通信如何实现" aria-hidden="true">#</a> 23、React组件通信如何实现?</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token literal-property property">React组件间通信方式</span><span class="token operator">:</span>

	<span class="token number">1</span><span class="token punctuation">)</span>父组件向子组件通讯<span class="token operator">:</span> 父组件可以向子组件通过传 props 的方式，向子组件进行通讯
	<span class="token number">2</span><span class="token punctuation">)</span>子组件向父组件通讯<span class="token operator">:</span> props<span class="token operator">+</span>回调的方式<span class="token punctuation">,</span>父组件向子组件传递props进行通讯，此props为作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中
	<span class="token number">3</span><span class="token punctuation">)</span>兄弟组件通信<span class="token operator">:</span> 找到这两个兄弟节点共同的父节点<span class="token punctuation">,</span>结合上面两种方式由父节点转发信息进行通信
	<span class="token number">4</span><span class="token punctuation">)</span>跨层级通信<span class="token operator">:</span> Context设计目的是为了共享那些对于一个组件树而言是“全局”的数据，例如当前认证的用户、主题或首选语言<span class="token punctuation">,</span>对于跨越多层的全局数据通过Context通信再适合不过
	<span class="token number">5</span><span class="token punctuation">)</span>发布订阅模式<span class="token operator">:</span> 发布者发布事件，订阅者监听事件并做出反应<span class="token punctuation">,</span>我们可以通过引入event模块进行通信
	<span class="token number">6</span><span class="token punctuation">)</span>全局状态管理工具<span class="token operator">:</span> 借助Redux或者Mobx等全局状态管理工具进行通信<span class="token punctuation">,</span>这种工具会维护一个全局状态中心Store<span class="token punctuation">,</span>并根据不同的事件产生新的状态
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_24、react如何进行组件-逻辑复用" tabindex="-1"><a class="header-anchor" href="#_24、react如何进行组件-逻辑复用" aria-hidden="true">#</a> 24、React如何进行组件/逻辑复用?</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token number">1</span><span class="token punctuation">)</span>高阶组件<span class="token operator">:</span>
	<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token function">属性代理</span>
	<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>反向继承
<span class="token number">2</span><span class="token punctuation">)</span>渲染属性
<span class="token number">3</span><span class="token punctuation">)</span>react<span class="token operator">-</span>hooks
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_25、redux的工作流程" tabindex="-1"><a class="header-anchor" href="#_25、redux的工作流程" aria-hidden="true">#</a> 25、redux的工作流程?</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>首先，我们看下几个核心概念：
	<span class="token number">1</span><span class="token punctuation">)</span>Store：保存数据的地方，你可以把它看成一个容器，整个应用只能有一个Store。
	<span class="token number">2</span><span class="token punctuation">)</span>State：Store对象包含所有数据，如果想得到某个时点的数据，就要对Store生成快照，这种时点的数据集合，就叫做State。
	<span class="token number">3</span><span class="token punctuation">)</span>Action：State的变化，会导致View的变化。但是，用户接触不到State，只能接触到View。所以，<span class="token number">4</span><span class="token punctuation">)</span>State的变化必须是View导致的。Action就是View发出的通知，表示State应该要发生变化了。
	<span class="token number">5</span><span class="token punctuation">)</span>Action Creator：View要发送多少种消息，就会有多少种Action。如果都手写，会很麻烦，所以我们定义一个函数来生成Action，这个函数就叫Action Creator。
	<span class="token number">6</span><span class="token punctuation">)</span>Reducer：Store收到Action以后，必须给出一个新的State，这样View才会发生变化。这种State的计算过程就叫做Reducer。Reducer是一个函数，它接受Action和当前State作为参数，返回一个新的State。
	<span class="token number">7</span><span class="token punctuation">)</span>dispatch：是View发出Action的唯一方法。
然后整个工作流程：
    <span class="token number">1</span><span class="token punctuation">)</span>首先，用户（通过View）发出Action，发出方式就用到了dispatch方法。
	<span class="token number">2</span><span class="token punctuation">)</span>然后，Store自动调用Reducer，并且传入两个参数：当前State和收到的Action，Reducer会返回新的State。
<span class="token number">3</span>）State一旦有变化，Store就会调用监听函数，来更新View。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="_26、redux中如何进行异步操作" tabindex="-1"><a class="header-anchor" href="#_26、redux中如何进行异步操作" aria-hidden="true">#</a> 26、redux中如何进行异步操作?</h4><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>	当然<span class="token punctuation">,</span>我们可以在componentDidmount中直接进行请求无须借助redux<span class="token punctuation">.</span>
	但是在一定规模的项目中<span class="token punctuation">,</span>上述方法很难进行异步流的管理<span class="token punctuation">,</span>通常情况下我们会借助redux的异步中间件进行异步处理<span class="token punctuation">.</span>
	redux异步流中间件其实有很多<span class="token punctuation">,</span>但是当下主流的异步中间件只有两种redux<span class="token operator">-</span>thunk、redux<span class="token operator">-</span>saga，当然redux<span class="token operator">-</span>observable可能也有资格占据一席之地<span class="token punctuation">,</span>其余的异步中间件不管是社区活跃度还是npm下载量都比较差了。
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,54),c=[i];function p(o,r){return n(),s("div",null,c)}const l=a(t,[["render",p],["__file","09-react高频面试题.html.vue"]]);export{l as default};
